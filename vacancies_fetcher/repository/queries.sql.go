// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package repository

import (
	"context"
)

const addVacancies = `-- name: AddVacancies :exec
insert into vacancies (key_word, href, title)
values ($1::text, unnest($2::text[]), unnest($3::text[]))
`

type AddVacanciesParams struct {
	KeyWord string
	Hrefs   []string
	Titles  []string
}

func (q *Queries) AddVacancies(ctx context.Context, arg AddVacanciesParams) error {
	_, err := q.db.Exec(ctx, addVacancies, arg.KeyWord, arg.Hrefs, arg.Titles)
	return err
}

const getVacanciesByKeyWord = `-- name: GetVacanciesByKeyWord :many
select href, title, max(id) from vacancies
where key_word = $1::text
limit $3::int offset $2::int
`

type GetVacanciesByKeyWordParams struct {
	KeyWord   string
	OffsetVal int32
	LimitVal  int32
}

type GetVacanciesByKeyWordRow struct {
	Href  string
	Title string
	Max   interface{}
}

func (q *Queries) GetVacanciesByKeyWord(ctx context.Context, arg GetVacanciesByKeyWordParams) ([]GetVacanciesByKeyWordRow, error) {
	rows, err := q.db.Query(ctx, getVacanciesByKeyWord, arg.KeyWord, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVacanciesByKeyWordRow
	for rows.Next() {
		var i GetVacanciesByKeyWordRow
		if err := rows.Scan(&i.Href, &i.Title, &i.Max); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
